---
- name: Comprehensive K3s Node Conflict Diagnostics
  hosts: localhost
  connection: local
  become: yes
  gather_facts: yes

  vars:
    diagnostic_output: []
    errors: []
    warnings: []
    ok_checks: []

  tasks:
    #########################################################################
    # 1. IPTABLES CONFLICTS CHECK
    #########################################################################
    - name: Check for duplicate iptables rules
      shell: |
        iptables -S | sort | uniq -d
      register: iptables_duplicates
      changed_when: false
      failed_when: false

    - name: Check iptables rule count per chain
      shell: |
        echo "INPUT: $(iptables -S INPUT | wc -l)"
        echo "OUTPUT: $(iptables -S OUTPUT | wc -l)"
        echo "FORWARD: $(iptables -S FORWARD | wc -l)"
      register: iptables_counts
      changed_when: false

    - name: Analyze iptables conflicts
      set_fact:
        iptables_status: |
          {% if iptables_duplicates.stdout != "" %}
          âŒ DUPLICATE RULES FOUND:
          {{ iptables_duplicates.stdout }}
          {% else %}
          âœ… No duplicate iptables rules
          {% endif %}

    - name: Add iptables analysis to results
      set_fact:
        diagnostic_output: "{{ diagnostic_output + [iptables_status] }}"
      when: iptables_duplicates.stdout != ""

    - name: Mark iptables as OK or error
      set_fact:
        errors: "{{ errors + ['iptables: duplicate rules'] }}"
      when: iptables_duplicates.stdout != ""

    - name: Mark iptables as OK
      set_fact:
        ok_checks: "{{ ok_checks + ['iptables'] }}"
      when: iptables_duplicates.stdout == ""

    #########################################################################
    # 2. SYSCTL CONFLICTS CHECK
    #########################################################################
    - name: Check for conflicting sysctl files
      shell: |
        grep -h "net.netfilter.nf_conntrack_max" /etc/sysctl.d/*.conf /etc/sysctl.conf 2>/dev/null | \
          awk -F: '{print $1}' | sort | uniq -c | awk '$1 > 1 {print}'
      register: sysctl_conntrack_conflict
      changed_when: false
      failed_when: false

    - name: Check for tcp_max_syn_backlog conflicts
      shell: |
        grep -h "net.ipv4.tcp_max_syn_backlog" /etc/sysctl.d/*.conf /etc/sysctl.conf 2>/dev/null | \
          awk '{print $3}' | sort | uniq -c
      register: sysctl_syn_values
      changed_when: false
      failed_when: false

    - name: Check sysctl conflicts
      shell: |
        for param in net.netfilter.nf_conntrack_max net.ipv4.tcp_max_syn_backlog net.ipv4.tcp_syncookies; do
          files=$(grep -l "^${param}" /etc/sysctl.d/*.conf 2>/dev/null)
          count=$(echo "$files" | grep -c .)
          if [ $count -gt 1 ]; then
            echo "âš ï¸  $param defined in $count files:"
            echo "$files" | sed 's/^/   /'
          fi
        done
      register: sysctl_conflicts
      changed_when: false
      failed_when: false

    - name: Add sysctl conflicts to results
      set_fact:
        diagnostic_output: "{{ diagnostic_output + [sysctl_conflicts.stdout] }}"
      when: sysctl_conflicts.stdout != ""

    - name: Mark sysctl status
      set_fact:
        warnings: "{{ warnings + ['sysctl: potential conflicts'] }}"
      when: sysctl_conflicts.stdout != ""

    - name: Mark sysctl as OK
      set_fact:
        ok_checks: "{{ ok_checks + ['sysctl'] }}"
      when: sysctl_conflicts.stdout == ""

    #########################################################################
    # 3. PORT CONFLICTS CHECK (FIXED: FILTER K3S PORTS)
    #########################################################################
    - name: Get honeypot PID
      shell: "ps aux | grep '[h]oneypot.py' | awk '{print $2}'"
      register: honeypot_pid
      changed_when: false
      failed_when: false

    - name: Check for port conflicts (exclude K3s etcd ports 2379, 2380)
      shell: |
        netstat -tlnp 2>/dev/null | awk 'NR>2 {print $4, $7}' | \
          awk -F: '{print $NF}' | grep -v '^2379$' | grep -v '^2380$' | \
          sort | uniq -c | awk '$1 > 1 {print "âš ï¸  Port", $2, "used by", $1, "processes"}'
      register: port_conflicts
      changed_when: false
      failed_when: false

    - name: Check honeypot vs real service ports (exclude honeypot PID)
      shell: |
        honeypot_pid='{{ honeypot_pid.stdout }}'
        if [ -z "$honeypot_pid" ]; then
          exit 0
        fi
        honeypot_ports="21 22 23 25 110 143 3306 3389 5432"
        conflicts=""
        for port in $honeypot_ports; do
          real_service=$(netstat -tlnp 2>/dev/null | grep ":$port " | grep -v "$honeypot_pid" | grep -v honeypot | awk '{print $7}')
          if [ -n "$real_service" ]; then
            conflicts="${conflicts}âŒ Port $port: honeypot conflicts with $real_service\n"
          fi
        done
        if [ -n "$conflicts" ]; then
          printf "%b" "$conflicts"
        fi
      register: honeypot_conflicts
      changed_when: false
      failed_when: false

    - name: Add port conflicts to results
      set_fact:
        diagnostic_output: "{{ diagnostic_output + [port_conflicts.stdout] }}"
      when: port_conflicts.stdout != ""

    - name: Add honeypot conflicts to results
      set_fact:
        diagnostic_output: "{{ diagnostic_output + [honeypot_conflicts.stdout] }}"
      when: honeypot_conflicts.stdout != ""

    - name: Mark port status
      set_fact:
        errors: "{{ errors + ['ports: conflicts detected'] }}"
      when: honeypot_conflicts.stdout != ""

    - name: Mark ports as warning
      set_fact:
        warnings: "{{ warnings + ['ports: duplicate bindings'] }}"
      when: port_conflicts.stdout != "" and honeypot_conflicts.stdout == ""

    - name: Mark ports as OK
      set_fact:
        ok_checks: "{{ ok_checks + ['ports'] }}"
      when: port_conflicts.stdout == "" and honeypot_conflicts.stdout == ""

    #########################################################################
    # 4. SYSTEMD SERVICE CONFLICTS (FIXED: CLEAN OUTPUT)
    #########################################################################
    - name: Detect main network interface
      shell: "ip route get 1 | awk '{print $5; exit}'"
      register: main_iface
      changed_when: false

    - name: Check for failed security services
      shell: |
        main_iface='{{ main_iface.stdout }}'
        failures=""
        for service in fail2ban psad arpwatch-${main_iface} arpwatch-cni0 honeypot; do
          if systemctl is-enabled $service &>/dev/null; then
            status=$(systemctl is-active $service)
            if [ "$status" != "active" ]; then
              failures="${failures}âŒ $service: $status\n"
            fi
          fi
        done
        if [ -n "$failures" ]; then
          printf "%b" "$failures"
        fi
      register: service_failures
      changed_when: false
      failed_when: false

    - name: Check for duplicate services on same ports
      shell: |
        count=$(systemctl list-units --type=service --state=running | grep -E 'ssh|sshd' | wc -l)
        if [ $count -gt 1 ]; then
          echo "âš ï¸  Multiple SSH services running: $count"
        fi
      register: duplicate_services
      changed_when: false
      failed_when: false

    - name: Add service failures to results
      set_fact:
        diagnostic_output: "{{ diagnostic_output + [service_failures.stdout] }}"
      when: service_failures.stdout != ""

    - name: Add duplicate services to results
      set_fact:
        diagnostic_output: "{{ diagnostic_output + [duplicate_services.stdout] }}"
      when: duplicate_services.stdout != ""

    - name: Mark services status
      set_fact:
        errors: "{{ errors + ['services: failures detected'] }}"
      when: service_failures.stdout != ""

    - name: Mark services as warning
      set_fact:
        warnings: "{{ warnings + ['services: duplicates detected'] }}"
      when: duplicate_services.stdout != "" and service_failures.stdout == ""

    - name: Mark services as OK
      set_fact:
        ok_checks: "{{ ok_checks + ['services'] }}"
      when: service_failures.stdout == "" and duplicate_services.stdout == ""

    #########################################################################
    # 5. KERNEL MODULE CONFLICTS
    #########################################################################
    - name: Check for conflicting kernel modules
      shell: |
        conflicts=""
        if lsmod | grep -q ipt_recent && lsmod | grep -q xt_recent; then
          conflicts="${conflicts}âŒ xt_recent and ipt_recent both loaded (conflict)\n"
        fi
        if ! lsmod | grep -q nf_conntrack; then
          conflicts="${conflicts}âš ï¸  nf_conntrack not loaded (required for iptables)\n"
        fi
        for mod in iptable_filter iptable_nat ip_tables; do
          if ! lsmod | grep -q "^$mod "; then
            conflicts="${conflicts}âš ï¸  $mod not loaded\n"
          fi
        done
        if [ -n "$conflicts" ]; then
          printf "%b" "$conflicts"
        fi
      register: module_conflicts
      changed_when: false
      failed_when: false

    - name: Add module conflicts to results
      set_fact:
        diagnostic_output: "{{ diagnostic_output + [module_conflicts.stdout] }}"
      when: module_conflicts.stdout != ""

    - name: Mark modules status
      set_fact:
        errors: "{{ errors + ['modules: conflicts detected'] }}"
      when: module_conflicts.stdout | regex_search('âŒ')

    - name: Mark modules as warning
      set_fact:
        warnings: "{{ warnings + ['modules: missing required'] }}"
      when: module_conflicts.stdout | regex_search('âš ï¸') and not (module_conflicts.stdout | regex_search('âŒ'))

    - name: Mark modules as OK
      set_fact:
        ok_checks: "{{ ok_checks + ['kernel_modules'] }}"
      when: module_conflicts.stdout == ""

    #########################################################################
    # 6. IPSET CONFLICTS CHECK
    #########################################################################
    - name: Check ipset set conflicts
      shell: |
        conflicts=""
        duplicates=$(ipset list -n | sort | uniq -d)
        if [ -n "$duplicates" ]; then
          while IFS= read -r set; do
            conflicts="${conflicts}âŒ Duplicate ipset: $set\n"
          done <<< "$duplicates"
        fi
        for set in fail2ban-sshd fail2ban-honeypot blacklist; do
          if ! ipset list -n | grep -q "^$set$"; then
            conflicts="${conflicts}âš ï¸  Missing ipset: $set\n"
          fi
        done
        if [ -n "$conflicts" ]; then
          printf "%b" "$conflicts"
        fi
      register: ipset_conflicts
      changed_when: false
      failed_when: false

    - name: Check ipset in iptables
      shell: |
        unused=""
        for set in blacklist fail2ban-sshd fail2ban-honeypot; do
          if ipset list -n | grep -q "^$set$"; then
            if ! iptables -S | grep -q "match-set $set"; then
              unused="${unused}âš ï¸  ipset $set exists but not used in iptables\n"
            fi
          fi
        done
        if [ -n "$unused" ]; then
          printf "%b" "$unused"
        fi
      register: ipset_unused
      changed_when: false
      failed_when: false

    - name: Add ipset conflicts to results
      set_fact:
        diagnostic_output: "{{ diagnostic_output + [ipset_conflicts.stdout] }}"
      when: ipset_conflicts.stdout != ""

    - name: Add ipset unused to results
      set_fact:
        diagnostic_output: "{{ diagnostic_output + [ipset_unused.stdout] }}"
      when: ipset_unused.stdout != ""

    - name: Mark ipset status
      set_fact:
        errors: "{{ errors + ['ipset: duplicates/conflicts'] }}"
      when: ipset_conflicts.stdout | regex_search('âŒ')

    - name: Mark ipset as warning
      set_fact:
        warnings: "{{ warnings + ['ipset: configuration issues'] }}"
      when: (ipset_conflicts.stdout | regex_search('âš ï¸') or ipset_unused.stdout != "") and not (ipset_conflicts.stdout | regex_search('âŒ'))

    - name: Mark ipset as OK
      set_fact:
        ok_checks: "{{ ok_checks + ['ipset'] }}"
      when: ipset_conflicts.stdout == "" and ipset_unused.stdout == ""

    #########################################################################
    # 7. XT_RECENT CHECK
    #########################################################################
    - name: Check xt_recent functionality
      shell: |
        issues=""
        if ! lsmod | grep -q xt_recent; then
          issues="${issues}âŒ xt_recent module not loaded\n"
        fi
        for list in ssh_attack portscan; do
          if [ ! -f /proc/net/xt_recent/$list ]; then
            issues="${issues}âš ï¸  xt_recent list '$list' not created\n"
          fi
        done
        if ! iptables -S | grep -q "recent.*ssh_attack"; then
          issues="${issues}âš ï¸  No iptables rules using xt_recent for SSH\n"
        fi
        if [ -n "$issues" ]; then
          printf "%b" "$issues"
        fi
      register: xt_recent_check
      changed_when: false
      failed_when: false

    - name: Add xt_recent issues to results
      set_fact:
        diagnostic_output: "{{ diagnostic_output + [xt_recent_check.stdout] }}"
      when: xt_recent_check.stdout != ""

    - name: Mark xt_recent status
      set_fact:
        errors: "{{ errors + ['xt_recent: not working'] }}"
      when: xt_recent_check.stdout | regex_search('âŒ')

    - name: Mark xt_recent as warning
      set_fact:
        warnings: "{{ warnings + ['xt_recent: incomplete setup'] }}"
      when: xt_recent_check.stdout | regex_search('âš ï¸') and not (xt_recent_check.stdout | regex_search('âŒ'))

    - name: Mark xt_recent as OK
      set_fact:
        ok_checks: "{{ ok_checks + ['xt_recent'] }}"
      when: xt_recent_check.stdout == ""

    #########################################################################
    # 8. RESOURCE USAGE CHECK
    #########################################################################
    - name: Check resource usage
      shell: |
        issues=""
        mem_total=$(free -m | awk '/^Mem:/ {print $2}')
        mem_used=$(free -m | awk '/^Mem:/ {print $3}')
        mem_percent=$((mem_used * 100 / mem_total))
        if [ $mem_percent -gt 90 ]; then
          issues="${issues}âŒ Memory usage critical: ${mem_percent}%\n"
        elif [ $mem_percent -gt 80 ]; then
          issues="${issues}âš ï¸  Memory usage high: ${mem_percent}%\n"
        fi
        cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
        if [ $(echo "$cpu_usage > 90" | bc) -eq 1 ]; then
          issues="${issues}âŒ CPU usage critical: ${cpu_usage}%\n"
        elif [ $(echo "$cpu_usage > 80" | bc) -eq 1 ]; then
          issues="${issues}âš ï¸  CPU usage high: ${cpu_usage}%\n"
        fi
        disk_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
        if [ $disk_usage -gt 90 ]; then
          issues="${issues}âŒ Disk usage critical: ${disk_usage}%\n"
        elif [ $disk_usage -gt 80 ]; then
          issues="${issues}âš ï¸  Disk usage high: ${disk_usage}%\n"
        fi
        if [ -n "$issues" ]; then
          printf "%b" "$issues"
        fi
      register: resource_issues
      changed_when: false
      failed_when: false

    - name: Add resource issues to results
      set_fact:
        diagnostic_output: "{{ diagnostic_output + [resource_issues.stdout] }}"
      when: resource_issues.stdout != ""

    - name: Mark resources status
      set_fact:
        errors: "{{ errors + ['resources: critical levels'] }}"
      when: resource_issues.stdout | regex_search('âŒ')

    - name: Mark resources as warning
      set_fact:
        warnings: "{{ warnings + ['resources: high usage'] }}"
      when: resource_issues.stdout | regex_search('âš ï¸') and not (resource_issues.stdout | regex_search('âŒ'))

    - name: Mark resources as OK
      set_fact:
        ok_checks: "{{ ok_checks + ['resources'] }}"
      when: resource_issues.stdout == ""

    #########################################################################
    # FINAL REPORT
    #########################################################################
    - name: Generate minimal diagnostic report
      debug:
        msg: |
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          K3S NODE COMPREHENSIVE DIAGNOSTICS
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          ğŸ“Š SUMMARY:
          âœ… OK: {{ ok_checks | length }}/8 checks passed
          {% if warnings | length > 0 %}
          âš ï¸  WARNINGS: {{ warnings | length }}
          {% endif %}
          {% if errors | length > 0 %}
          âŒ ERRORS: {{ errors | length }}
          {% endif %}
          
          {% if errors | length > 0 %}
          âŒ CRITICAL ISSUES:
          {% for error in errors %}
            â€¢ {{ error }}
          {% endfor %}
          {% endif %}
          
          {% if warnings | length > 0 %}
          âš ï¸  WARNINGS:
          {% for warning in warnings %}
            â€¢ {{ warning }}
          {% endfor %}
          {% endif %}
          
          {% if diagnostic_output | length > 0 %}
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          DETAILED FINDINGS:
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          {% for finding in diagnostic_output %}
          {{ finding }}
          {% endfor %}
          {% endif %}
          
          {% if errors | length == 0 and warnings | length == 0 %}
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          ğŸ‰ ALL CHECKS PASSED - NO CONFLICTS DETECTED!
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          {% endif %}
          
          Run: /usr/local/bin/k3s-conflict-check for quick check
